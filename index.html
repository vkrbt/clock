<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NYC Clock</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            font-family: 'Georgia', serif;
        }

        .clock-container {
            position: relative;
            width: min(90vw, 90vh, 600px);
            height: min(90vw, 90vh, 600px);
            filter: drop-shadow(0 20px 50px rgba(0, 0, 0, 0.5));
            overflow: hidden;
        }

        .clock-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .clock-layer img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .clock-face {
            z-index: 1;
        }

        .hour-hand {
            z-index: 2;
        }

        .minute-hand {
            z-index: 3;
        }

        .second-hand {
            z-index: 4;
        }

        .digital-clock {
            margin-top: 30px;
            font-family: 'Courier New', monospace;
            font-size: clamp(1.5rem, 5vw, 3rem);
            color: #b8956c;
            text-shadow: 0 0 20px rgba(184, 149, 108, 0.4);
            letter-spacing: 0.15em;
            background: linear-gradient(180deg, #b8956c 0%, #8b7355 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="confetti-canvas"></canvas>
    <div class="wrapper">
    <div class="clock-container">
        <div class="clock-layer clock-face">
            <img src="clock.png" alt="Циферблат">
        </div>
        <div class="clock-layer hour-hand hand" id="hour">
            <img src="hour.png" alt="Часовая стрелка">
        </div>
        <div class="clock-layer minute-hand hand" id="minute">
            <img src="minute.png" alt="Минутная стрелка">
        </div>
        <div class="clock-layer second-hand hand" id="second">
            <img src="second.png" alt="Секундная стрелка">
        </div>
    </div>
    <div class="digital-clock" id="digital">00:00:00</div>
    </div>

    <script>
        const hourHand = document.getElementById('hour');
        const minuteHand = document.getElementById('minute');
        const secondHand = document.getElementById('second');
        const digitalClock = document.getElementById('digital');

        // Храним накопленные углы, чтобы избежать дёрганья при переходе через 12
        let prevSecondDeg = null;
        let prevMinuteDeg = null;
        let prevHourDeg = null;
        let secondOffset = 0;
        let minuteOffset = 0;
        let hourOffset = 0;

        // Предзагрузка звука курантов
        const chimesAudio = new Audio('clock.mp3');
        chimesAudio.preload = 'auto';
        let chimesDuration = 0;
        let chimesReady = false;
        let chimesStartSecond = 0; // Секунда, когда нужно начать воспроизведение
        let chimesPlaying = false; // Флаг, что куранты уже играют в этой минуте

        chimesAudio.addEventListener('loadedmetadata', () => {
            chimesDuration = chimesAudio.duration;
            // Рассчитываем секунду старта: звук должен закончиться к 0-й секунде следующей минуты
            chimesStartSecond = Math.ceil(60 - chimesDuration);
            chimesReady = true;
            console.log(`Куранты загружены: ${chimesDuration.toFixed(1)}с, старт на ${chimesStartSecond}-й секунде`);
            
            // Проверяем, не загрузилась ли страница в момент, когда звук уже должен играть
            const now = new Date();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();
            
            if (seconds >= chimesStartSecond) {
                // Рассчитываем, с какой позиции начать воспроизведение
                const secondsUntilMinuteEnd = 60 - seconds - (milliseconds / 1000);
                const startOffset = chimesDuration - secondsUntilMinuteEnd;
                
                if (startOffset >= 0 && startOffset < chimesDuration) {
                    chimesAudio.currentTime = startOffset;
                    chimesAudio.play().then(() => {
                        chimesPlaying = true;
                        console.log(`Куранты запущены с ${startOffset.toFixed(1)}с (страница загружена во время воспроизведения)`);
                    }).catch(() => {});
                }
            }
        });

        chimesAudio.addEventListener('canplaythrough', () => {
            chimesReady = true;
        });

        // Принудительная загрузка
        chimesAudio.load();

        // ===== КОНФЕТТИ И ХЛОПУШКА =====
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiParticles = [];
        let confettiAnimating = false;

        function resizeConfettiCanvas() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        resizeConfettiCanvas();
        window.addEventListener('resize', resizeConfettiCanvas);

        // Цвета конфетти
        const confettiColors = [
            '#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#ff6bd6',
            '#c9b037', '#ad8a56', '#f0e68c', '#ffa500', '#ff4500',
            '#00ff7f', '#ff1493', '#00bfff', '#ff69b4', '#ffd700'
        ];

        class ConfettiParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 20;
                this.vy = Math.random() * -18 - 5;
                this.gravity = 0.4;
                this.drag = 0.99;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 15;
                this.width = Math.random() * 10 + 5;
                this.height = Math.random() * 6 + 3;
                this.color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                this.opacity = 1;
                this.wobble = Math.random() * 10;
                this.wobbleSpeed = Math.random() * 0.1 + 0.05;
            }

            update() {
                this.vy += this.gravity;
                this.vx *= this.drag;
                this.vy *= this.drag;
                this.x += this.vx + Math.sin(this.wobble) * 2;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
                this.wobble += this.wobbleSpeed;
                
                if (this.y > confettiCanvas.height + 50) {
                    this.opacity -= 0.02;
                }
            }

            draw() {
                confettiCtx.save();
                confettiCtx.translate(this.x, this.y);
                confettiCtx.rotate(this.rotation * Math.PI / 180);
                confettiCtx.globalAlpha = this.opacity;
                confettiCtx.fillStyle = this.color;
                confettiCtx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                confettiCtx.restore();
            }
        }

        function launchConfetti() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // Создаём 150 частиц
            for (let i = 0; i < 150; i++) {
                confettiParticles.push(new ConfettiParticle(centerX, centerY));
            }
            
            if (!confettiAnimating) {
                confettiAnimating = true;
                animateConfetti();
            }
        }

        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            
            confettiParticles = confettiParticles.filter(p => p.opacity > 0);
            
            confettiParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            if (confettiParticles.length > 0) {
                requestAnimationFrame(animateConfetti);
            } else {
                confettiAnimating = false;
            }
        }

        // Web Audio API для звука хлопушки
        let audioContext = null;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Звук хлопушки
        function playPopSound() {
            initAudioContext();
            if (!audioContext) return;
            
            // Пробуем возобновить если suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
                return;
            }
            
            const now = audioContext.currentTime;
            
            // Белый шум для хлопка
            const bufferSize = audioContext.sampleRate * 0.3;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                // Экспоненциально затухающий шум
                noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioContext.sampleRate * 0.03));
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            // Фильтр для более мягкого звука
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 500;
            
            const filter2 = audioContext.createBiquadFilter();
            filter2.type = 'lowpass';
            filter2.frequency.value = 4000;
            
            // Громкость
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.6, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            
            noise.connect(filter);
            filter.connect(filter2);
            filter2.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            noise.start(now);
            
            // Добавляем "свист" разлетающегося конфетти
            const swoosh = audioContext.createOscillator();
            swoosh.type = 'sine';
            swoosh.frequency.setValueAtTime(800, now);
            swoosh.frequency.exponentialRampToValueAtTime(200, now + 0.15);
            
            const swooshGain = audioContext.createGain();
            swooshGain.gain.setValueAtTime(0.1, now);
            swooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            swoosh.connect(swooshGain);
            swooshGain.connect(audioContext.destination);
            
            swoosh.start(now);
            swoosh.stop(now + 0.2);
        }

        function celebrate() {
            playPopSound();
            launchConfetti();
        }

        // Отслеживаем начало новой минуты
        let lastCelebrateMinute = -1;

        function pad(num) {
            return num.toString().padStart(2, '0');
        }

        function updateClock() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();

            // Запускаем куранты так, чтобы они закончились ровно к началу новой минуты
            if (chimesReady && seconds >= chimesStartSecond && !chimesPlaying) {
                // Рассчитываем точное время старта для синхронизации
                const secondsUntilMinuteEnd = 60 - seconds - (milliseconds / 1000);
                const startOffset = chimesDuration - secondsUntilMinuteEnd;
                
                if (startOffset >= 0 && startOffset < chimesDuration) {
                    chimesAudio.currentTime = startOffset;
                    chimesAudio.play().then(() => {
                        chimesPlaying = true;
                    }).catch(() => {});
                }
            }
            
            // Сбрасываем флаг в начале минуты
            if (seconds < chimesStartSecond && chimesPlaying) {
                chimesPlaying = false;
            }

            // Конфетти при начале новой минуты (секунды = 0)
            if (seconds === 0 && minutes !== lastCelebrateMinute) {
                lastCelebrateMinute = minutes;
                celebrate();
            }

            // Базовые углы
            let secondsDeg = (seconds + milliseconds / 1000) * 6;
            let minutesDeg = minutes * 6 + (seconds + milliseconds / 1000) * 0.1;
            let hoursDeg = (hours % 12) * 30 + minutes * 0.5 + seconds * (0.5 / 60);

            // Корректируем переход через 360° → 0°
            if (prevSecondDeg !== null && prevSecondDeg > 300 && secondsDeg < 60) {
                secondOffset += 360;
            }
            if (prevMinuteDeg !== null && prevMinuteDeg > 300 && minutesDeg < 60) {
                minuteOffset += 360;
            }
            if (prevHourDeg !== null && prevHourDeg > 300 && hoursDeg < 60) {
                hourOffset += 360;
            }

            prevSecondDeg = secondsDeg;
            prevMinuteDeg = minutesDeg;
            prevHourDeg = hoursDeg;

            secondHand.style.transform = `rotate(${secondsDeg + secondOffset}deg)`;
            minuteHand.style.transform = `rotate(${minutesDeg + minuteOffset}deg)`;
            hourHand.style.transform = `rotate(${hoursDeg + hourOffset}deg)`;

            // Обновляем цифровые часы
            digitalClock.textContent = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }

        // Первый запуск
        updateClock();

        // Используем requestAnimationFrame для максимальной плавности
        function tick() {
            updateClock();
            requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
    </script>
</body>
</html>

